----------------------Calculate-------------------------------
-Conditions
[x] 1. If a is the first event and is an internal or send event, then LC(a) = 1.
[x] 2. If a is the first event and is a receive event, then LC(a) = k + 1 where k is the LC-value of the send event corresponding to a (that has occurred at a process other than P).
[x]3. If a is not the first event and is an internal or send event, then  LC(a) = k + 1 where k is the LC-value of the event just before a at process P.
[x]4. If  a is not the first event and is a receive event, let b be the send event corresponding to a (that has occurred at a process other than P) and k be the clock value of the event just before a at process P. Then LC(a) = max{ k, LC(b) } + 1

// let a = events
//     T = terminal
//     S = send
//     R = receive

mutex mtx;
condition_variable cv; 

//shared resource

vector<pair<string,int>> send
int max_sleeper = # of n;
int sleeper = max_sleeper;  

**Notes: // will account for the number of processors that needs to finish executing before joining all the processors together.
	 // if max_sleeper = 0 then all the threads can join and output the result.
//Find the max of both the corresponding LC(send) and the LC value before the receive event then add 1 and return it.
calcMaxLC(sent, beforeRcv)
---------------------------------------------------------------------------------------------------------------------
  // sent = corresponding send event.
  // beforeRcv = before the receive event.
  if(sent > beforeRcv){
	return sent +1;
  }
  else{
	return beforeRcv+1;
  }

calculateLC(arr, result, i)
--------------------------------------------------------------------------------------------------------------------------
//make sure the list is not null or the first event is not null.
if(!arr.empty() || arr[0] != NULL)

int j = 0;

//no such thing as a global clock.
int k = 0;

// calculate the initiator state
if (a == R){
  //put the thread to sleep. 
  unique_lock<mutex> lck(mtx);
  sleeper++;
  cv.wait(lck);
  k = send.front().second+1;
  send.pop();
  lck.unlock();
}
else if (a != R){
  result[i][j] = ++k;
  //send event;
  if(a == S){
    x = make_pair(a,1);
    mtx.lock();
    send.push(x);
    mtx.unlock();
  }
}
j++;
for(i to n){
  if(a == R && send.front().first == a){
    //put the thread to sleep. 
    unique_lock<mutex> lck(mtx);
    sleeper++;
    cv.wait(lck);
    k = calcMaxLC(send.front().second,arr[j-1]);
    send.pop();
    lck.unlock();
  }
  else if(a != R){
    result[i][j] = ++k;
    //send event;
    if(a == S){
      x = make_pair(a,k);
      mtx.lock();
      send.push(x);
      mtx.unlock();
    }
  }
}

Stopping condition: receive events with no send decrement sleep var.
mtx.lock()
max_sleeper--;
mtx.unlock();
---------------------------------------------------------------------------------------------------------

breakDeadEnd
--------------------------------------------------------------------------------------------------------
while(max_sleeper != 0){
  if(sle	eper == max_sleeper){
    lock_guard<mutex> lck(mtx);
    sleeper = 0;
    cv.notify_all();
  }	
}


--------------------------------------------------------------------------------------------------------

main
---------------------------------------------------------------------------------------------------------
m = # of events;
n = # of processors;
sample_array[m][n];

//spawn N threads with thread content calling CalculateLC
thread proc[n];
for( i to n ){
  proc[i] = thread(calculateLC, sample_array[i], i); 
}

//spawn thread that will wake up all the threads when sleeper == max_sleeper **notify_all().
thread helper(breakDeadEnd);
for( i to n){
  proc[i].join();
}
helper.join();

//print out the result
for( i to n){
	for( j to m){
		cout << result[i][j] << " ";
	}
	cout << endl;
}

